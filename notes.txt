Ideas:
  * Create a Document/Record class
    - hydrate, dehydrate, cast, etc
  * Create a GQLParser class to consolidate Model and Field classes... pass raw gql to data/Model, data/Field

Bugs:
  * What if you defined @index without @model?
  * Embedded documents do not work!
    - Currently embedded document is being saved as it's own collection/node
    - Cannot update apartment.building
    - Cannot query where building.tenants, etc
    - Concept only fits document databases (what about neo4j and sql databases?)
    - How to create index on embedded objects? building.type unique?

Todo:
  * Verify that Rules are passed parameters one would need to do custom logic
  * Error handling; Rules need better error messages
  * Mutation should have meta input (how to define meta props?)
  * Get a list of references that would be onDelete affected
  * Currently there is no way to count regular elements of an array (try to count bids)
  * URL validator

Figure out:
  * createdBy? (Audit trail)
  * Composite Rule Definitions?
  * Context. (tenants, segmentation, language)
  * Authorization. Specifically owner records, segmentation, recursive data resolution

Open Questions:
  * Where/How to define stores?
  * Should updatedAt be set when a document is created? Should it be configurable?

Integration Concerns
  * AutoGraph returns base64 id's for pagination; how to mix APIs and slowly migrate?

Refs:
  * https://jbt.github.io/markdown-editor/
