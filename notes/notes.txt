Next Release:
  * Would be nice to query in mode where none of the @value stuff is used (migration scripts etc)
  * Allow FK by arbitrary value (ie. workspace.name)
  * Allow input to be data model (not just graphql schema)
  * Finalize flags() vs options() - possibly use resolver.match(model, flags)
  * WRITE A TEST THAT SHOWS resolveModelWhereClause (if (where.id) where.id = map(where.id, v => model.idValue(v));)
    - its needed...

  -------------

Next Release:
  * Reconsider SystemEvent args
    - Perhaps pass an object that you call toObject() on (like query) that gives you normalized/removed keys
  * Finalize Driver Interface - consider moving out of Autograph into new NPM module
  * Deep sort (akin to where clause resolution?)
    - You are currently thwarted since key order is not preserved...
  * Add query.context() option to override @value etc????
    - OR you could have .update() .create() which would be the equiv to .native()
    - Maybe something like .force()...
  * .archive() would be useful to softDelete yet still emit delete event
  * Rearchitect GraphQL AST manipulations
  * Rearchitect nested subsplice disaster
    - Can this be solved via the new update array api?

  -------------

Bugs:
  * Nested embedded object in array cannot delete without doing an explicit $pull operation (race condition)
    - Drivers need concept of push and pull
  * MongoDB cannot-create-namespace-in-multi-document-transaction (collection must first be defined)
  * Fields with alias (keys) as the same name as other fields do not save properly eg:
      DataPackage.network: Network @field(key: "networkId") # Collides with networkId field
      DataPackage.networkId: ID # Legacy attribute so it's still needed

Performance:
  * Select as alias/key can be done at the driver level (not require transformation during hydration)
    - This is not so easy when it comes to embedded objects (mongo does not support it)
  * Verify that Transformer + Rules are only being called when needed

Next:
  * Incorporate Logger
  * Support @value on Model itself?
  * Framework directive param validation
  * Neo4j does not know how to generate ids
    - ID Value Strategy (MongoID, String, etc)
  * I don't think you have "distinct" and "noRepeat" figured out and implemented (you can move noRepeat to enforce)
  ? Possibly rename input type to end with Input (eg. CreatePersonInput)

Enhancements:
  * Lodash Transformers
  * Would be nice to have FK by another field (ie. name "live" in order to link workspace)
  * Create person with books at the same time
  * createdAt, updatedAt, counts, onDeletes, references, etc should be controllable
  * Add 'filterBy' as an option for post query filtering (this can alleviate the depth-first where clause problem)
  * Concept of "incomplete" and "what's missing" as part of data retrieval
  * Get a list of references that would be onDelete affected
  * URL, RGB, RGBA, validator?
  * Composite Rule Definitions?
  * helper methods:
    - field.getPathFromModel(model) => 'a.b.c.d';

Todo:
  * MeteorUser _id is a String (not ID). How to handle?
    - How about expicit ID definition?
  * Allow Field and Model to be extended (directive fields)
  * Are you able to flatten fields? (ie. firstName, lastName but save to profile.firstName, profile.lastName in DB)
    - Confirmed that you cannot.
  * Input types are not models and therefor cannot participate in Transformers|Rules
    - Is this really needed? I guess perhaps when using the DOA directly...
  * Embedded documents (outside of Mongo) do not work!
    - How to handle join-table in SQL?
    - How to create index on embedded objects? building.type unique?

Ideas:
  * If the Query holds all the information you can move logic to it (eg. Query.validate())
  * Can you use semver over glob in some areas?

Figure out:
  * createdBy? (Audit trail)
  * Authorization. Specifically owner records, segmentation, recursive data resolution

How:
  data: {
    type: Mongo.Mixed,
    required: true,
    $onDelete: {
      key: 'data.id',
      op: 'unset',
      $set: { '../../../status': 'incomplete' },
      ref: {
        Category: { '../../type': 'category' },
        NetworkCuratedList: { '../../type': 'list', network_id: { $exists: 1 } },
      },
    },
  }

Refs:
  * https://jbt.github.io/markdown-editor/
  * https://gist.github.com/rxaviers/7360908
  * https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet
  * https://stackoverflow.com/questions/44639309/javascript-difference-between-reflect-get-and-objfoo
  * https://nodesource.com/blog/understanding-streams-in-nodejs/
  * https://www.freecodecamp.org/news/node-js-streams-everything-you-need-to-know-c9141306be93/
  * https://www.smashingmagazine.com/2012/11/writing-fast-memory-efficient-javascript/

db.getCollection('network_place').aggregate([
  {
    $facet: {
      docs: [
        {
          $addFields: {
            dataId: { $toString: '$dataId' },
          }
        },
        {
          $match: { dataType: "site" },
        },
      ],
      count: [
        { $match: { dataType: "site" } },
        { $count: 'count' }
      ],
      totalCount: [
        { $count: 'totalCount' }
      ]
    }
  }
]);
