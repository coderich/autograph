Release 0.5:
  * Incorporate Logger
  * Bug: id field does not exist on the schema until schema.getServerApiSchema() is called; move these default schema types to creation of schema instance; leave the rest of the API in the schema.getServerApiSchema() call.
  * You know EventEmitter wants to emit Query (will be a breaking change so consider when to do it)
  * Verify that Rules are passed parameters one would need to do custom logic (resolver sounds about right; what about context?, Query?)
  * deserialize should set default values if undefined
  * Can you add resolver to context.autograph yourself? (not require it to be done externally)
  * Can you make Emitter events part of a transaction? pre vs post can be confusing... especially for data validation etc.
  ---------
  1) Must pass in "Driver" class inside stores.js
  2) Should NOT create schema.js overriding resolvers (use @annotations etc instead)

Bug:
  * Where clause with .one({ required: true }) does not work
  * Nested embedded object in array cannot delete without doing an explicit $pull operation (race condition)
    - Drivers need concept of push and pull
  * DataLoaders are not being used propertly - need re-architecture

Performance:
  * Select as alias/key can be done at the driver level (not require transformation during hydration)
  * Pagination should pass limit & sort to dao if possible
    - Can all queries default sort by _id? Is this the Mongo default thing to do?
  * Post-Query hydration needs to be faster

Now:
  * Idea of push | pull on the driver would be ideal
  * Need idea of archive/soft-delete to remove from resultSet

Next:
  * Support @value on Model itself
  * Framework directive param validation
  * Take a look at all Mongoose options/features (eg. minimize)
  * Neo4j does not know how to generate ids
  * Deserialization and ids (_id) and code throughout (remove _id in deserlialization if possible)
  * How do you handle the hydrate() problem? QueryWorker is hydrating, what about concept of returning ResultSet and letting user hydrate() or populate() from resolver?
  * I don't think you have "distinct" and "noRepeat" figured out and implemented (you can move noRepeat to enforce)

Enhancements:
  * ID Value Strategy (MongoID, String, etc)
  * Lodash Transformers
  * Create person with books at the same time
  * createdAt, updatedAt, counts, onDeletes, references, etc should be controllable
  * ResultSet can have helper methods (save(), remove(), archive(), etc())
  * Add 'filterBy' as an option for post query filtering (this can alleviate the depth-first where clause problem)
  * Concept of "incomplete" and "what's missing" as part of data retrieval
  * Get a list of references that would be onDelete affected
  * URL, RGB, RGBA, validator?
  * Composite Rule Definitions?
  * Password and PasswordMatch validation; enforce strength; password can be created/updated but not selected, what's the scope?
    - Answer: crud: "cu"

Todo:
  * MeteorUser _id is a String (not ID). How to handle?
    - How about expicit ID definition?
  * Currently there is no way to count regular elements of an array (try to count bids)
  * Allow Field and Model to be extended (directive fields)
  * Are you able to flatten fields? (ie. firstName, lastName but save to profile.firstName, profile.lastName in DB)
    - Confirmed that you cannot.
  * Input types are not models and therefor cannot participate in Transformers|Rules
    - Is this really needed? I guess perhaps when using the DOA directly...
  * Embedded documents (outside of Mongo) do not work!
    - How to handle join-table in SQL?
    - How to create index on embedded objects? building.type unique?

Ideas:
  * If the Query holds all the information you can move logic to it (eg. Query.validate())
  * Can you use semver over glob in some areas?

Figure out:
  * createdBy? (Audit trail)
  * Authorization. Specifically owner records, segmentation, recursive data resolution
  * dependencies vs peerDependencies (graphql)
  * What was the reason for Query vs Find? Do you need it? I know it had to do with final stage of sorting/filtering/pagination.

How:
  data: {
    type: Mongo.Mixed,
    required: true,
    $onDelete: {
      key: 'data.id',
      op: 'unset',
      $set: { '../../../status': 'incomplete' },
      ref: {
        Category: { '../../type': 'category' },
        NetworkCuratedList: { '../../type': 'list', network_id: { $exists: 1 } },
      },
    },
  }

Refs:
  * https://jbt.github.io/markdown-editor/
  * https://gist.github.com/rxaviers/7360908
  * https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet
  * https://stackoverflow.com/questions/44639309/javascript-difference-between-reflect-get-and-objfoo
