Breaking changes:
  * scope: no longer supports resolver|segment (use @value instead)
  * scope completely removed!; use crud + persist
  * alias -> key

* All fields must be in the list of model fields (id, createdAt, updatedAt, etc)
* ResultSet.resolve may need to be consolidated to Field.resolve and used both in-out of DB

Now:
  * Enforce segmentation throughout (findNetwork, network field, ...)
    - But that means you can't use the resolver straight up and say where { 'network.name': 'name' }
    - See if (above) is a problem since you have .native and .raw now

Next:
  * Verify that Rules are passed parameters one would need to do custom logic (resolver sounds about right)
  * I don't think you have "distinct" and "noRepeat" figured out and implemented (you can move noRepeat to enforce)
  * Can context be derived from the schema instead of being explicitly set?

Enhancements:
  * ResultSet have have helper methods (save(), remove(), archive(), etc())
  * Add 'filterBy' as an option for post query filtering (this can alleviate the depth-first where clause problem)
  * Where clause allow explicit NULL to be searchable (ie. where { authored: null } gives those who have not authored anything)
  * Concept of "incomplete" and "what's missing" as part of data retrieval
  * Get a list of references that would be onDelete affected
  * URL, RGB, RGBA, validator?
  * Composite Rule Definitions?
  * Password and PasswordMatch validation; enforce strength; password can be created/updated but not selected, what's the scope?
    - Answer: crud: "cu"

Todo:
  * Incorporate Logger
  * MeteorUser _id is a String (not ID). How to handle?
  * Can you make Emitter events part of a transaction? pre vs post can be confusing... especially for data validation etc.
  * Currently there is no way to count regular elements of an array (try to count bids)
  * Allow Field and Model to be extended (directive fields)
  * Are you able to flatten fields? (ie. firstName, lastName but save to profile.firstName, profile.lastName in DB)
    - Confirmed that you cannot.
  * Input types are not models and therefor cannot participate in Transformers|Rules
    - Is this really needed? I guess perhaps when using the DOA directly...
  * Embedded documents (outside of Mongo) do not work!
    - How to handle join-table in SQL?
    - How to create index on embedded objects? building.type unique?

Ideas:
  * If the Query holds all the information you can move logic to it (eg. Query.validate())
  * Can you use semver over glob in some areas?
  * Concept of a named query (re-usable)? resolver.namedQuery(...)

Figure out:
  * createdBy? (Audit trail)
  * Authorization. Specifically owner records, segmentation, recursive data resolution
  * dependencies vs peerDependencies (graphql)
  * What was the reason for Query vs Find? Do you need it? I know it had to do with final stage of sorting/filtering/pagination.

Refs:
  * https://jbt.github.io/markdown-editor/
  * https://gist.github.com/rxaviers/7360908
  * https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet
  * https://stackoverflow.com/questions/44639309/javascript-difference-between-reflect-get-and-objfoo
